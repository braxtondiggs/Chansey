import { QueryFailedError } from 'typeorm';

import { createHash } from 'node:crypto';

import { BacktestService } from './backtest.service';
import { MarketDataSource, MarketDataTimeframe } from './market-data-set.entity';

/**
 * Focused tests for default dataset management in BacktestService:
 * - ensureDefaultDatasetExists()
 * - getDefaultDatasetId()
 */
describe('BacktestService – default dataset', () => {
  let service: BacktestService;
  let marketDataSetRepo: Record<string, jest.Mock>;
  let ohlcService: Record<string, jest.Mock>;
  let coinService: Record<string, jest.Mock>;

  const mockDateRange = { start: new Date('2024-01-01'), end: new Date('2025-01-01') };
  const mockCoinIds = ['btc', 'eth'];
  const mockCoins = [
    { id: 'btc', symbol: 'BTC' },
    { id: 'eth', symbol: 'ETH' }
  ];

  const buildMockDataset = (overrides: Record<string, any> = {}) => ({
    id: 'dataset-uuid-1',
    label: 'Available Historical Data',
    source: MarketDataSource.INTERNAL_CAPTURE,
    instrumentUniverse: ['BTC', 'ETH'],
    timeframe: MarketDataTimeframe.HOUR,
    startAt: mockDateRange.start,
    endAt: mockDateRange.end,
    integrityScore: 90,
    checksum: 'abc123',
    storageLocation: '',
    replayCapable: false,
    metadata: { autoGenerated: true, source: 'ohlc-candle-table' },
    ...overrides
  });

  beforeEach(() => {
    ohlcService = {
      getCoinsWithCandleData: jest.fn().mockResolvedValue(mockCoinIds),
      getCandleDataDateRange: jest.fn().mockResolvedValue(mockDateRange),
      getCandleCount: jest.fn().mockResolvedValue(10000)
    };

    coinService = {
      getCoinsByIds: jest.fn().mockResolvedValue(mockCoins)
    };

    const queryBuilder = {
      where: jest.fn().mockReturnThis(),
      getOne: jest.fn().mockResolvedValue(null)
    };

    marketDataSetRepo = {
      createQueryBuilder: jest.fn().mockReturnValue(queryBuilder),
      create: jest.fn().mockImplementation((data) => ({ id: 'new-uuid', ...data })),
      save: jest.fn().mockImplementation((entity) => Promise.resolve({ id: 'new-uuid', ...entity })),
      update: jest.fn().mockResolvedValue(undefined),
      findOne: jest.fn().mockResolvedValue(null),
      find: jest.fn().mockResolvedValue([])
    };

    // Construct BacktestService with minimal mocks — only dataset-related deps matter
    service = new BacktestService(
      {} as any, // algorithmService
      coinService as any, // coinService
      ohlcService as any, // ohlcService
      {} as any, // backtestEngine
      {} as any, // backtestStream
      {} as any, // backtestResultService
      {} as any, // datasetValidator
      {} as any, // backtestRepository
      {} as any, // backtestTradeRepository
      {} as any, // backtestSnapshotRepository
      marketDataSetRepo as any, // marketDataSetRepository
      {} as any, // backtestSignalRepository
      {} as any, // simulatedFillRepository
      {} as any, // comparisonReportRepository
      {} as any, // comparisonReportRunRepository
      {} as any, // historicalQueue
      {} as any, // replayQueue
      {} as any, // backtestPauseService
      undefined // metricsService
    );
  });

  describe('ensureDefaultDatasetExists', () => {
    const getExpectedChecksum = (symbols: string[], range = mockDateRange) => {
      const checksumData = `${[...symbols].sort().join(',')}-${range.start.toISOString()}-${range.end.toISOString()}`;
      return createHash('sha256').update(checksumData).digest('hex').substring(0, 16);
    };

    it('returns null when no OHLC data is available', async () => {
      ohlcService.getCoinsWithCandleData.mockResolvedValue([]);

      const result = await service.ensureDefaultDatasetExists();

      expect(result).toBeNull();
      expect(marketDataSetRepo.createQueryBuilder).not.toHaveBeenCalled();
    });

    it('returns null when date range is null', async () => {
      ohlcService.getCandleDataDateRange.mockResolvedValue(null);

      const result = await service.ensureDefaultDatasetExists();

      expect(result).toBeNull();
    });

    it('returns null when no valid coins found', async () => {
      coinService.getCoinsByIds.mockResolvedValue([{ id: 'btc', symbol: '' }]);

      const result = await service.ensureDefaultDatasetExists();

      expect(result).toBeNull();
    });

    it('creates a new dataset when none exists', async () => {
      const savedDataset = buildMockDataset();
      marketDataSetRepo.save.mockResolvedValue(savedDataset);

      const result = await service.ensureDefaultDatasetExists();

      expect(marketDataSetRepo.create).toHaveBeenCalledWith(
        expect.objectContaining({
          label: 'Available Historical Data',
          source: MarketDataSource.INTERNAL_CAPTURE,
          instrumentUniverse: ['BTC', 'ETH'],
          timeframe: MarketDataTimeframe.HOUR,
          replayCapable: false,
          metadata: expect.objectContaining({ autoGenerated: true })
        })
      );
      expect(marketDataSetRepo.save).toHaveBeenCalled();
      expect(result).toEqual(savedDataset);
    });

    it('computes checksum using sorted instrument universe', async () => {
      marketDataSetRepo.save.mockResolvedValue(buildMockDataset());
      coinService.getCoinsByIds.mockResolvedValue([
        { id: 'eth', symbol: 'ETH' },
        { id: 'btc', symbol: 'BTC' }
      ]);

      await service.ensureDefaultDatasetExists();

      const expectedChecksum = getExpectedChecksum(['ETH', 'BTC']);
      expect(marketDataSetRepo.create).toHaveBeenCalledWith(
        expect.objectContaining({
          checksum: expectedChecksum
        })
      );
    });

    it('updates an existing dataset when one is found', async () => {
      const existingDataset = buildMockDataset({ id: 'existing-uuid' });
      const queryBuilder = {
        where: jest.fn().mockReturnThis(),
        getOne: jest.fn().mockResolvedValue(existingDataset)
      };
      marketDataSetRepo.createQueryBuilder.mockReturnValue(queryBuilder);
      marketDataSetRepo.findOne.mockResolvedValue({ ...existingDataset, checksum: 'updated' });

      const result = await service.ensureDefaultDatasetExists();

      expect(marketDataSetRepo.update).toHaveBeenCalledWith(
        'existing-uuid',
        expect.objectContaining({
          label: 'Available Historical Data',
          instrumentUniverse: ['BTC', 'ETH']
        })
      );
      expect(marketDataSetRepo.save).not.toHaveBeenCalled();
      expect(result).toBeTruthy();
      expect(result!.id).toBe('existing-uuid');
    });

    it('handles concurrent insert by catching unique constraint violation', async () => {
      const concurrentDataset = buildMockDataset({ id: 'concurrent-uuid' });

      // First call: queryBuilder finds nothing
      let callCount = 0;
      const queryBuilder = {
        where: jest.fn().mockReturnThis(),
        getOne: jest.fn().mockImplementation(() => {
          callCount++;
          // First call returns null (no existing), second call returns the concurrently-created dataset
          return callCount === 1 ? null : concurrentDataset;
        })
      };
      marketDataSetRepo.createQueryBuilder.mockReturnValue(queryBuilder);

      // save throws unique constraint violation (must be QueryFailedError for isUniqueConstraintViolation)
      const driverError = { code: '23505' };
      const uniqueError = new QueryFailedError('INSERT INTO ...', [], driverError as unknown as Error);
      marketDataSetRepo.save.mockRejectedValue(uniqueError);

      const result = await service.ensureDefaultDatasetExists();

      expect(result).toEqual(concurrentDataset);
    });

    it('re-checks the database when cached checksum does not match', async () => {
      const savedDataset = buildMockDataset();
      marketDataSetRepo.save.mockResolvedValue(savedDataset);

      // First call populates cache
      await service.ensureDefaultDatasetExists();

      const newDateRange = { start: new Date('2024-02-01'), end: new Date('2025-02-01') };
      ohlcService.getCandleDataDateRange.mockResolvedValue(newDateRange);
      marketDataSetRepo.createQueryBuilder.mockClear();

      await service.ensureDefaultDatasetExists();

      expect(marketDataSetRepo.createQueryBuilder).toHaveBeenCalled();
    });

    it('returns cached dataset on subsequent calls within TTL', async () => {
      const savedDataset = buildMockDataset();
      marketDataSetRepo.save.mockResolvedValue(savedDataset);

      // First call populates cache
      await service.ensureDefaultDatasetExists();

      // Reset mocks to verify no DB calls on second invocation
      marketDataSetRepo.createQueryBuilder.mockClear();
      ohlcService.getCoinsWithCandleData.mockClear();

      // Second call should hit cache
      const result = await service.ensureDefaultDatasetExists();

      expect(result).toEqual(savedDataset);
      // Still calls OHLC service to check data freshness (checksum comparison)
      // but should not query for existing dataset if checksum matches
    });

    it('returns null and does not throw on DB error', async () => {
      marketDataSetRepo.save.mockRejectedValue(new Error('connection lost'));
      const queryBuilder = {
        where: jest.fn().mockReturnThis(),
        getOne: jest.fn().mockResolvedValue(null)
      };
      marketDataSetRepo.createQueryBuilder.mockReturnValue(queryBuilder);

      const result = await service.ensureDefaultDatasetExists();

      expect(result).toBeNull();
    });
  });

  describe('getDefaultDatasetId', () => {
    it('returns null when no auto-generated dataset exists', async () => {
      const queryBuilder = {
        where: jest.fn().mockReturnThis(),
        getOne: jest.fn().mockResolvedValue(null)
      };
      marketDataSetRepo.createQueryBuilder.mockReturnValue(queryBuilder);

      const result = await service.getDefaultDatasetId();

      expect(result).toBeNull();
    });

    it('returns the dataset ID from DB query', async () => {
      const dataset = buildMockDataset({ id: 'found-uuid', checksum: 'xyz' });
      const queryBuilder = {
        where: jest.fn().mockReturnThis(),
        getOne: jest.fn().mockResolvedValue(dataset)
      };
      marketDataSetRepo.createQueryBuilder.mockReturnValue(queryBuilder);

      const result = await service.getDefaultDatasetId();

      expect(result).toBe('found-uuid');
    });

    it('populates cache after DB lookup', async () => {
      const dataset = buildMockDataset({ id: 'cached-uuid', checksum: 'xyz' });
      const queryBuilder = {
        where: jest.fn().mockReturnThis(),
        getOne: jest.fn().mockResolvedValue(dataset)
      };
      marketDataSetRepo.createQueryBuilder.mockReturnValue(queryBuilder);

      // First call hits DB
      await service.getDefaultDatasetId();

      // Clear mocks, second call should use cache
      marketDataSetRepo.createQueryBuilder.mockClear();

      const result = await service.getDefaultDatasetId();

      expect(result).toBe('cached-uuid');
      expect(marketDataSetRepo.createQueryBuilder).not.toHaveBeenCalled();
    });

    it('returns cached ID when cache is still valid', async () => {
      // Prime the cache via ensureDefaultDatasetExists
      const savedDataset = buildMockDataset({ id: 'primed-uuid' });
      marketDataSetRepo.save.mockResolvedValue(savedDataset);
      await service.ensureDefaultDatasetExists();

      // Clear mocks
      marketDataSetRepo.createQueryBuilder.mockClear();

      const result = await service.getDefaultDatasetId();

      expect(result).toBe('primed-uuid');
      expect(marketDataSetRepo.createQueryBuilder).not.toHaveBeenCalled();
    });

    it('queries DB again when cache is expired', async () => {
      const savedDataset = buildMockDataset({ id: 'cached-uuid' });
      marketDataSetRepo.save.mockResolvedValue(savedDataset);

      const nowSpy = jest.spyOn(Date, 'now');
      nowSpy.mockReturnValue(1_000_000);
      await service.ensureDefaultDatasetExists();

      const queryBuilder = {
        where: jest.fn().mockReturnThis(),
        getOne: jest.fn().mockResolvedValue(savedDataset)
      };
      marketDataSetRepo.createQueryBuilder.mockReturnValue(queryBuilder);

      // Advance time beyond cache TTL (5 minutes)
      nowSpy.mockReturnValue(1_000_000 + 6 * 60 * 1000);

      const result = await service.getDefaultDatasetId();

      expect(result).toBe('cached-uuid');
      expect(marketDataSetRepo.createQueryBuilder).toHaveBeenCalled();

      nowSpy.mockRestore();
    });
  });
});
